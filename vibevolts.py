import numpy as np
from datetime import datetime, timezone, timedelta
from typing import Dict, Any, List, Optional, Tuple
import io

# The astropy library is required for accurate astronomical calculations.
# You can install it with: pip install astropy jplephem
from astropy.time import Time
from astropy.coordinates import get_body, GCRS, ITRS, EarthLocation, solar_system_ephemeris
import astropy.units as u

# The sgp4 library is required for parsing TLE files.
# You can install it with: pip install sgp4
from sgp4.api import Satrec

# The plotly library is required for 3D plotting.
# You can install it with: pip install plotly
import plotly.graph_objects as go

# Import the point generation function
from generate_log_spherical_points import generate_log_spherical_points


# --- Global Constants for Array Indices ---
# These constants define column indices for numpy arrays, making the
# code more readable and preventing errors from using "magic numbers".

# -- Radii in Meters --
EARTH_RADIUS = 6378137.0
MOON_RADIUS = 1737400.0

# -- Detector Array Indices --
DETECTOR_APERTURE_IDX = 0      # Aperture size in meters
DETECTOR_PIXEL_SIZE_IDX = 1    # Pixel size in radians
DETECTOR_QE_IDX = 2            # Quantum efficiency as a fraction (0.0 to 1.0)
DETECTOR_PIXELS_IDX = 3        # Total number of pixels in the detector (count)
DETECTOR_SOLAR_EXCL_IDX = 4    # Solar exclusion angle in radians
DETECTOR_LUNAR_EXCL_IDX = 5    # Lunar exclusion angle in radians
DETECTOR_EARTH_EXCL_IDX = 6    # Earth exclusion angle (above the limb) in radians

# -- Orbital Elements Array Indices --
ORBITAL_A_IDX = 0              # Semi-major axis in meters
ORBITAL_E_IDX = 1              # Eccentricity (dimensionless)
ORBITAL_I_IDX = 2              # Inclination in radians
ORBITAL_RAAN_IDX = 3           # Right Ascension of the Ascending Node in radians
ORBITAL_ARGP_IDX = 4           # Argument of Perigee in radians
ORBITAL_M_IDX = 5              # Mean Anomaly in radians


def initializeStructures(
    num_satellites: int,
    num_observatories: int,
    num_red_satellites: int,
    start_time: datetime
) -> Dict[str, Any]:
    """
    Initializes categorized data structures for a space simulation.

    This function creates distinct sets of data components for different categories
    of entities. It includes kinematic data, orbital elements, sensor pointing
    information, and detailed detector characteristics.

    The 'orbital_elements' component contains the following columns:
    - 0: Semi-major axis (meters)
    - 1: Eccentricity
    - 2: Inclination (radians)
    - 3: Right Ascension of the Ascending Node (radians)
    - 4: Argument of Perigee (radians)
    - 5: Mean Anomaly (radians)

    The 'detector' component contains the following columns:
    - 0: Aperture size (meters)
    - 1: Pixel size (radians)
    - 2: Quantum Efficiency (fraction)
    - 3: Pixel count (total number)
    - 4: Solar exclusion angle (radians)
    - 5: Lunar exclusion angle (radians)
    - 6: Earth exclusion angle (radians, above the limb)

    The 'fixedpoints' component is initialized with a set of 10,000 static points
    in the GCRS frame, generated by `generate_log_spherical_points`. These
    points have a logarithmic radial distribution and are intended for various
    fixed-point calculations or as a reference grid.

    All kinematic data is for the Geocentric Celestial Reference System (GCRS).
    Angles are relative to the International Celestial Reference System (ICRS).
    Distances are in meters, angles in radians, and time in seconds.

    Args:
        num_satellites: The number of regular space-based sensors.
        num_observatories: The number of ground-based sensors.
        num_red_satellites: The number of special "red" satellites.
        start_time: The starting time and date of the simulation. This must be a
                    timezone-aware datetime object set to UTC.

    Returns:
        A dictionary representing the simulation state, containing categorized data.
    """
    # --- Input Validation ---
    if not isinstance(num_satellites, int) or num_satellites < 0:
        raise ValueError("num_satellites must be a non-negative integer.")
    if not isinstance(num_observatories, int) or num_observatories < 0:
        raise ValueError("num_observatories must be a non-negative integer.")
    if not isinstance(num_red_satellites, int) or num_red_satellites < 0:
        raise ValueError("num_red_satellites must be a non-negative integer.")
    if not isinstance(start_time, datetime):
        raise TypeError("start_time must be a datetime object.")
    if start_time.tzinfo is None:
        raise ValueError("start_time must be timezone-aware. Please set tzinfo.")


    # --- Main Data Structure ---
    simulation_data: Dict[str, Any] = {
        'start_time': start_time,
        'counts': {
            'celestial': 2,  # Sun and Moon
            'satellites': num_satellites,
            'observatories': num_observatories,
            'red_satellites': num_red_satellites
        },

        'celestial': {
            'position': np.zeros((2, 3), dtype=float),
            'velocity': np.zeros((2, 3), dtype=float),
            'acceleration': np.zeros((2, 3), dtype=float),
        },

        'satellites': {
            'position': np.zeros((num_satellites, 3), dtype=float),
            'velocity': np.zeros((num_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_satellites, 6), dtype=float),
            'epochs': [], # List to store datetime epochs for each satellite
            'pointing': np.zeros((num_satellites, 3), dtype=float),
            'detector': np.zeros((num_satellites, 7), dtype=float),
        },

        'observatories': {
            'position': np.zeros((num_observatories, 3), dtype=float),
            'velocity': np.zeros((num_observatories, 3), dtype=float),
            'acceleration': np.zeros((num_observatories, 3), dtype=float),
            'pointing': np.zeros((num_observatories, 3), dtype=float),
            'detector': np.zeros((num_observatories, 7), dtype=float),
        },
        
        'red_satellites': {
            'position': np.zeros((num_red_satellites, 3), dtype=float),
            'velocity': np.zeros((num_red_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_red_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_red_satellites, 6), dtype=float),
            'epochs': [],
            'pointing': np.zeros((num_red_satellites, 3), dtype=float),
            'detector': np.zeros((num_red_satellites, 7), dtype=float),
        },

        'fixedpoints': {
            'position': generate_log_spherical_points(
                num_points=10000,
                inner_radius=2000000,
                # Outer radius is 2 * geostationary radius (42,164 km)
                # This is an interpretation of "tice geodistances".
                outer_radius=84328000
            )
        }
    }
    
    return simulation_data

def celestial_update(data_struct: Dict[str, Any], time_date: datetime) -> Dict[str, Any]:
    """
    Calculates and updates the positions of the Sun and Moon.

    This function uses the astropy library to get the precise GCRS coordinates
    of the Sun and Moon for the given time, and updates the 'celestial' position
    component in the main data structure. Velocities and accelerations are not
    calculated and remain zero.

    Args:
        data_struct: The main simulation data dictionary from initializeStructures.
        time_date: The timezone-aware datetime object (in UTC) for the calculation.

    Returns:
        The modified data_struct with updated celestial positions.
    """
    if time_date.tzinfo is None:
        raise ValueError("time_date must be timezone-aware.")

    # Convert the python datetime object to an astropy Time object
    astro_time = Time(time_date)

    # Get Sun position in the GCRS frame using the modern get_body function
    sun_coords = get_body("sun", astro_time)
    sun_gcrs = sun_coords.transform_to(GCRS(obstime=astro_time))
    
    # Get Moon position in the GCRS frame using the modern get_body function
    moon_coords = get_body("moon", astro_time)
    moon_gcrs = moon_coords.transform_to(GCRS(obstime=astro_time))

    # Update the celestial data arrays (index 0 for Sun, 1 for Moon)
    # Position data is converted from astropy's representation to a simple
    # numpy array in meters.
    celestial_pos = data_struct['celestial']['position']
    celestial_pos[0] = sun_gcrs.cartesian.xyz.to(u.m).value
    celestial_pos[1] = moon_gcrs.cartesian.xyz.to(u.m).value
    
    # Per request, velocity and acceleration are not calculated and remain as zeros.

    return data_struct

def readtle(tle_file_path: str) -> Tuple[np.ndarray, List[datetime]]:
    """
    Reads a TLE file and extracts orbital elements and epochs for each satellite.

    Args:
        tle_file_path: The path to the TLE file.

    Returns:
        A tuple containing:
        - A NumPy array of orbital elements.
        - A list of datetime objects representing the epoch for each satellite.
    """
    orbital_elements_list = []
    epochs_list = []
    with open(tle_file_path, 'r') as f:
        lines = f.readlines()

    # Iterate through the file, processing 3 lines at a time (name, line1, line2)
    for i in range(0, len(lines), 3):
        line1 = lines[i+1].strip()
        line2 = lines[i+2].strip()

        # Create a satellite object from the TLE data
        satellite = Satrec.twoline2rv(line1, line2)

        # Use the pre-calculated Julian date from the satellite object
        jd, fr = satellite.jdsatepoch, satellite.jdsatepochF
        epoch_dt = Time(jd, fr, format='jd', scale='utc').to_datetime(timezone.utc)
        epochs_list.append(epoch_dt)

        # Extract and convert orbital elements
        a = satellite.a * satellite.radiusearthkm * 1000.0
        e = satellite.ecco
        inc = satellite.inclo
        raan = satellite.nodeo
        argp = satellite.argpo
        M = satellite.mo

        elements = np.zeros(6)
        elements[ORBITAL_A_IDX] = a
        elements[ORBITAL_E_IDX] = e
        elements[ORBITAL_I_IDX] = inc
        elements[ORBITAL_RAAN_IDX] = raan
        elements[ORBITAL_ARGP_IDX] = argp
        elements[ORBITAL_M_IDX] = M
        orbital_elements_list.append(elements)

    return np.array(orbital_elements_list, dtype=float), epochs_list

def propagate_satellites(data_struct: Dict[str, Any], time_date: datetime) -> Dict[str, Any]:
    """
    Updates satellite positions based on their orbital elements for a given time.

    This function propagates the orbits of all satellites ('satellites' and 
    'red_satellites') from their TLE epoch to the specified time_date
    using Kepler's laws.

    Args:
        data_struct: The main simulation data dictionary.
        time_date: The timezone-aware datetime object (in UTC) to propagate to.

    Returns:
        The modified data_struct with updated satellite positions.
    """
    # Earth's standard gravitational parameter (m^3/s^2)
    MU_EARTH = 3.986004418e14
    
    time_date_timestamp = time_date.timestamp()

    for sat_category in ['satellites', 'red_satellites']:
        if data_struct['counts'][sat_category] == 0:
            continue

        elements = data_struct[sat_category]['orbital_elements']
        epochs = data_struct[sat_category]['epochs']
        
        # Calculate the time difference from each satellite's own epoch
        epoch_timestamps = np.array([e.timestamp() for e in epochs])
        delta_t_array = time_date_timestamp - epoch_timestamps

        # Extract orbital elements for all satellites in the category using constants
        a = elements[:, ORBITAL_A_IDX]
        e = elements[:, ORBITAL_E_IDX]
        i = elements[:, ORBITAL_I_IDX]
        raan = elements[:, ORBITAL_RAAN_IDX]
        argp = elements[:, ORBITAL_ARGP_IDX]
        M0 = elements[:, ORBITAL_M_IDX]

        # --- Vectorized Orbit Propagation ---
        
        # 1. Calculate mean motion
        n = np.sqrt(MU_EARTH / a**3)
        
        # 2. Calculate new mean anomaly
        M = (M0 + n * delta_t_array) % (2 * np.pi)

        # 3. Solve Kepler's Equation for Eccentric Anomaly (E) using Newton's method
        E = M.copy()  # Initial guess
        for _ in range(10): # Iterate a few times for convergence
            f_E = E - e * np.sin(E) - M
            f_prime_E = 1 - e * np.cos(E)
            # Avoid division by zero for circular orbits
            f_prime_E[f_prime_E == 0] = 1e-10
            E = E - f_E / f_prime_E

        # 4. Calculate True Anomaly (Î½)
        tan_nu_half = np.sqrt((1 + e) / (1 - e)) * np.tan(E / 2)
        nu = 2 * np.arctan(tan_nu_half)

        # 5. Calculate distance from center of Earth (r)
        r = a * (1 - e * np.cos(E))

        # 6. Calculate position in the perifocal (orbital) frame
        x_pqw = r * np.cos(nu)
        y_pqw = r * np.sin(nu)

        # 7. Rotate from perifocal to GCRS frame
        cos_raan = np.cos(raan)
        sin_raan = np.sin(raan)
        cos_argp = np.cos(argp)
        sin_argp = np.sin(argp)
        cos_i = np.cos(i)
        sin_i = np.sin(i)

        # Rotation matrix elements from PQW to GCRS (IJK)
        P_x = cos_argp * cos_raan - sin_argp * sin_raan * cos_i
        P_y = cos_argp * sin_raan + sin_argp * cos_raan * cos_i
        P_z = sin_argp * sin_i
        
        Q_x = -sin_argp * cos_raan - cos_argp * sin_raan * cos_i
        Q_y = -sin_argp * sin_raan + cos_argp * cos_raan * cos_i
        Q_z = cos_argp * sin_i

        # Perform the rotation
        x_gcrs = x_pqw * P_x + y_pqw * Q_x
        y_gcrs = x_pqw * P_y + y_pqw * Q_y
        z_gcrs = x_pqw * P_z + y_pqw * Q_z
        
        # Update the position array in the data structure
        data_struct[sat_category]['position'] = np.vstack((x_gcrs, y_gcrs, z_gcrs)).T

    return data_struct

def plot_positions_3d(positions: np.ndarray, title: str, plot_time: datetime, labels: Optional[List[str]] = None):
    """
    Displays a 3D interactive plot of object positions with Earth references.

    Args:
        positions: An (n x 3) NumPy array of (x, y, z) positions in meters.
        title: The title for the plot.
        plot_time: The UTC datetime for which the plot is generated. This is
                   used to correctly orient the Earth.
        labels: An optional list of names for each point to display on hover.
    """
    if positions.shape[1] != 3:
        raise ValueError("positions array must have 3 columns (x, y, z).")
        
    earth_radius = 6378137.0 # meters

    fig = go.Figure()

    # Add satellite markers
    fig.add_trace(go.Scatter3d(
        x=positions[:, 0],
        y=positions[:, 1],
        z=positions[:, 2],
        mode='markers',
        marker=dict(
            size=5,
            color=np.arange(len(positions)), # Color by index
            colorscale='Viridis',
            opacity=0.8
        ),
        text=labels,
        hoverinfo='text' if labels else 'none',
        name='Satellites'
    ))

    # Add a sphere to represent the Earth
    u_sphere = np.linspace(0, 2 * np.pi, 100)
    v_sphere = np.linspace(0, np.pi, 100)
    x_earth = earth_radius * np.outer(np.cos(u_sphere), np.sin(v_sphere))
    y_earth = earth_radius * np.outer(np.sin(u_sphere), np.sin(v_sphere))
    z_earth = earth_radius * np.outer(np.ones(np.size(u_sphere)), np.cos(v_sphere))
    fig.add_trace(go.Surface(x=x_earth, y=y_earth, z=z_earth, colorscale='Blues', showscale=False, opacity=0.5, name='Earth'))

    # Add Equator line
    theta = np.linspace(0, 2 * np.pi, 100)
    x_eq = earth_radius * np.cos(theta)
    y_eq = earth_radius * np.sin(theta)
    z_eq = np.zeros_like(theta)
    fig.add_trace(go.Scatter3d(x=x_eq, y=y_eq, z=z_eq, mode='lines', line=dict(color='green', width=3), name='Equator'))

    # Add North Pole marker
    fig.add_trace(go.Scatter3d(x=[0], y=[0], z=[earth_radius * 1.1], mode='text', text=['N'], textfont=dict(size=15, color='red'), name='North Pole'))

    # Add El Segundo marker
    lat_es = 33.92 * u.deg
    lon_es = -118.42 * u.deg
    el_segundo_loc = EarthLocation.from_geodetic(lon=lon_es, lat=lat_es)
    itrs_coords = el_segundo_loc.get_itrs(obstime=Time(plot_time))
    gcrs_coords = itrs_coords.transform_to(GCRS(obstime=Time(plot_time)))
    es_pos = gcrs_coords.cartesian.xyz.to(u.m).value * 1.05 # Scale slightly for visibility
    fig.add_trace(go.Scatter3d(x=[es_pos[0]], y=[es_pos[1]], z=[es_pos[2]], mode='text', text=['ES'], textfont=dict(size=15, color='yellow'), name='El Segundo'))


    fig.update_layout(
        title=title,
        scene=dict(
            xaxis_title='X (m)',
            yaxis_title='Y (m)',
            zaxis_title='Z (m)',
            aspectmode='data' # Ensures a 1:1:1 aspect ratio
        ),
        margin=dict(r=20, b=10, l=10, t=40),
        legend_title_text='Objects'
    )
    fig.show()


def solarexclusion(data_struct: Dict[str, Any]) -> Tuple[np.ndarray, np.ndarray]:
    """
    Calculates solar exclusion for all satellites based on their pointing vectors.

    This function operates in a vectorized manner on all satellites in the
    'satellites' category. It computes the angle between each satellite's
    pointing vector and the vector from the satellite to the Sun.

    Args:
        data_struct: The main simulation data dictionary.

    Returns:
        A tuple containing:
        - exclusion_vector (np.ndarray): An array of the same length as the
          number of satellites. An element is 1 if the satellite is within
          the solar exclusion angle, 0 otherwise.
        - angle_vector (np.ndarray): An array containing the calculated angle
          in radians for each satellite.
    """
    num_sats = data_struct['counts']['satellites']
    if num_sats == 0:
        return np.array([]), np.array([])

    # Get required data from the main structure
    sun_pos = data_struct['celestial']['position'][0]
    sat_pos = data_struct['satellites']['position']
    sat_pointing = data_struct['satellites']['pointing']
    solar_exclusion_angles = data_struct['satellites']['detector'][:, DETECTOR_SOLAR_EXCL_IDX]

    # Calculate the vector from each satellite to the Sun
    vec_sat_to_sun = sun_pos - sat_pos

    # Normalize the vectors
    norm_sat_to_sun = np.linalg.norm(vec_sat_to_sun, axis=1)
    norm_sat_pointing = np.linalg.norm(sat_pointing, axis=1)

    # Avoid division by zero for zero-length vectors.
    # A zero-length pointing vector can't have an angle, so we create a
    # mask to handle these cases safely.
    valid_norms = (norm_sat_to_sun > 1e-9) & (norm_sat_pointing > 1e-9)

    # Initialize angle vector with a default value (pi = 180 deg) for invalid cases
    angle_vector = np.full(num_sats, np.pi)

    # Calculate dot product only for vectors with valid norms
    if np.any(valid_norms):
        dot_product = np.einsum('ij,ij->i', vec_sat_to_sun[valid_norms], sat_pointing[valid_norms])

        # Calculate the angle where possible
        cos_angle = dot_product / (norm_sat_to_sun[valid_norms] * norm_sat_pointing[valid_norms])

        # Clip to handle potential floating point inaccuracies
        cos_angle = np.clip(cos_angle, -1.0, 1.0)

        angle_vector[valid_norms] = np.arccos(cos_angle)

    # Determine exclusion based on the angle
    exclusion_vector = (angle_vector < solar_exclusion_angles).astype(int)

    return exclusion_vector, angle_vector

def exclusion(data_struct: Dict[str, Any], satellite_index: int) -> bool:
    """
    Determines if a satellite's pointing vector is excluded by the Sun, Moon, or Earth.

    Args:
        data_struct: The main simulation data dictionary.
        satellite_index: The index of the satellite to check.

    Returns:
        True if the satellite's view is excluded, False otherwise.
    """
    # --- 1. Extract Data ---
    sat_pos = data_struct['satellites']['position'][satellite_index]
    sat_pointing = data_struct['satellites']['pointing'][satellite_index]
    sun_pos = data_struct['celestial']['position'][0]
    moon_pos = data_struct['celestial']['position'][1]
    
    # Get exclusion angles for the specific satellite
    detector_props = data_struct['satellites']['detector'][satellite_index]
    solar_excl_angle = detector_props[DETECTOR_SOLAR_EXCL_IDX]
    lunar_excl_angle = detector_props[DETECTOR_LUNAR_EXCL_IDX]
    earth_excl_angle = detector_props[DETECTOR_EARTH_EXCL_IDX]

    # --- 2. Compute Vectors and Normalize ---
    # Vector from satellite to celestial bodies
    vec_to_sun = sun_pos - sat_pos
    vec_to_moon = moon_pos - sat_pos
    vec_to_earth = -sat_pos  # Vector from satellite to Earth's center

    # Distances
    dist_to_sun = np.linalg.norm(vec_to_sun)
    dist_to_moon = np.linalg.norm(vec_to_moon)
    dist_to_earth = np.linalg.norm(vec_to_earth)
    
    # Normalize all relevant vectors to unit vectors
    # Handle potential zero-length vectors to avoid division by zero errors
    u_vec_to_sun = vec_to_sun / dist_to_sun if dist_to_sun > 0 else np.array([0., 0., 0.])
    u_vec_to_moon = vec_to_moon / dist_to_moon if dist_to_moon > 0 else np.array([0., 0., 0.])
    u_vec_to_earth = vec_to_earth / dist_to_earth if dist_to_earth > 0 else np.array([0., 0., 0.])
    
    norm_pointing = np.linalg.norm(sat_pointing)
    u_sat_pointing = sat_pointing / norm_pointing if norm_pointing > 0 else np.array([0., 0., 0.])

    # --- 3. Calculate Angles and Check for Exclusion ---
    sun_flag, moon_flag, earth_flag = False, False, False

    # -- Sun Exclusion --
    # Angle between pointing vector and sun vector
    cos_angle_sun = np.clip(np.dot(u_sat_pointing, u_vec_to_sun), -1.0, 1.0)
    angle_sun = np.arccos(cos_angle_sun)
    if angle_sun < solar_excl_angle:
        sun_flag = True

    # -- Moon Exclusion --
    # Angle between pointing vector and moon vector
    cos_angle_moon = np.clip(np.dot(u_sat_pointing, u_vec_to_moon), -1.0, 1.0)
    angle_moon = np.arccos(cos_angle_moon)
    # Apparent angular radius of the Moon from the satellite's perspective
    apparent_radius_moon = np.arctan(MOON_RADIUS / dist_to_moon) if dist_to_moon > 0 else 0
    if (angle_moon - apparent_radius_moon) < lunar_excl_angle:
        moon_flag = True

    # -- Earth Exclusion --
    # Angle between pointing vector and Earth vector
    cos_angle_earth = np.clip(np.dot(u_sat_pointing, u_vec_to_earth), -1.0, 1.0)
    angle_earth = np.arccos(cos_angle_earth)
    # Apparent angular radius of the Earth from the satellite's perspective
    apparent_radius_earth = np.arctan(EARTH_RADIUS / dist_to_earth) if dist_to_earth > 0 else 0
    if (angle_earth - apparent_radius_earth) < earth_excl_angle:
        earth_flag = True

    # --- 4. Set Global Exclusion Flag and Return ---
    is_excluded = sun_flag or moon_flag or earth_flag
    return is_excluded


def create_exclusion_table(data_struct: Dict[str, Any]) -> np.ndarray:
    """
    Creates a table of exclusion statuses for each satellite against each fixed point.

    For each satellite, this function iterates through every fixed point, sets the
    satellite's pointing vector towards that point, and calls the `exclusion`
    function to determine if that line of sight is blocked by the Sun, Moon, or Earth.

    Args:
        data_struct: The main simulation data dictionary, which must be fully
                     populated with satellite and celestial body positions.

    Returns:
        A 2D NumPy array where rows correspond to satellites and columns correspond
        to fixed points. A cell value of 1 means the view is excluded, and 0 means
        it is clear.
    """
    num_satellites = data_struct['counts']['satellites']
    fixed_points = data_struct['fixedpoints']['position']
    num_fixed_points = len(fixed_points)

    if num_satellites == 0 or num_fixed_points == 0:
        return np.array([[]])

    # Initialize the results table with zeros
    exclusion_tbl = np.zeros((num_satellites, num_fixed_points), dtype=int)

    # Get satellite positions
    satellite_positions = data_struct['satellites']['position']

    # Iterate through each satellite
    for i in range(num_satellites):
        sat_pos = satellite_positions[i]
        
        # Iterate through each fixed point
        for j in range(num_fixed_points):
            fixed_point_pos = fixed_points[j]
            
            # Temporarily set the satellite's pointing vector towards the fixed point
            # This is the crucial step for the check.
            pointing_vector = fixed_point_pos - sat_pos
            data_struct['satellites']['pointing'][i] = pointing_vector
            
            # Call the exclusion function for the current satellite
            if exclusion(data_struct, i):
                exclusion_tbl[i, j] = 1
            # No need for an else, as it's already 0
    
    return exclusion_tbl

def plot_pointing_vectors(data_struct: Dict[str, Any], title: str, plot_time: datetime):
    """
    Displays a 3D plot of satellites with their pointing vectors.

    Args:
        data_struct: The main simulation data dictionary.
        title: The title for the plot.
        plot_time: The UTC datetime for the plot, used for Earth orientation.
    """
    sat_positions = data_struct['satellites']['position']
    sat_pointing = data_struct['satellites']['pointing']
    num_sats = data_struct['counts']['satellites']

    if num_sats == 0:
        print("No satellites to plot.")
        return

    fig = go.Figure()

    # Add satellite markers
    fig.add_trace(go.Scatter3d(
        x=sat_positions[:, 0],
        y=sat_positions[:, 1],
        z=sat_positions[:, 2],
        mode='markers',
        marker=dict(size=5, color='blue', opacity=0.8),
        name='Satellites'
    ))

    # Add pointing vectors for each satellite
    # A scale factor makes the vectors visible. Doubled from 0.25 to 0.5.
    vector_scale = 0.5 * EARTH_RADIUS
    for i in range(num_sats):
        start_point = sat_positions[i]
        
        # Normalize the pointing vector before scaling
        pointing_vec = sat_pointing[i]
        norm = np.linalg.norm(pointing_vec)
        if norm > 0:
            unit_vec = pointing_vec / norm
        else:
            unit_vec = np.array([0, 0, 0]) # Handle zero-length pointing
            
        end_point = start_point + unit_vec * vector_scale
        
        fig.add_trace(go.Scatter3d(
            x=[start_point[0], end_point[0]],
            y=[start_point[1], end_point[1]],
            z=[start_point[2], end_point[2]],
            mode='lines',
            line=dict(color='red', width=3),
            showlegend=False # Don't add hundreds of legend entries
        ))

    # Add a sphere to represent the Earth
    u_sphere = np.linspace(0, 2 * np.pi, 100)
    v_sphere = np.linspace(0, np.pi, 100)
    x_earth = EARTH_RADIUS * np.outer(np.cos(u_sphere), np.sin(v_sphere))
    y_earth = EARTH_RADIUS * np.outer(np.sin(u_sphere), np.sin(v_sphere))
    z_earth = EARTH_RADIUS * np.outer(np.ones(np.size(u_sphere)), np.cos(v_sphere))
    fig.add_trace(go.Surface(x=x_earth, y=y_earth, z=z_earth, colorscale='Blues', showscale=False, opacity=0.5, name='Earth'))

    fig.update_layout(
        title=title,
        scene=dict(
            xaxis_title='X (m)',
            yaxis_title='Y (m)',
            zaxis_title='Z (m)',
            aspectmode='data'
        ),
        margin=dict(r=20, b=10, l=10, t=40)
    )
    fig.show()

