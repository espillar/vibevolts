import numpy as np
from datetime import datetime, timezone, timedelta
from typing import Dict, Any, List, Optional, Tuple
import io

# The astropy library is required for accurate astronomical calculations.
# You can install it with: pip install astropy jplephem
from astropy.time import Time
from astropy.coordinates import get_body, GCRS, ITRS, EarthLocation, solar_system_ephemeris
import astropy.units as u

# The sgp4 library is required for parsing TLE files.
# You can install it with: pip install sgp4
from sgp4.api import Satrec

# Import the point generation function
from generate_log_spherical_points import generate_log_spherical_points


# --- Global Constants for Array Indices ---
# These constants define column indices for numpy arrays, making the
# code more readable and preventing errors from using "magic numbers".

# -- Radii in Meters --
EARTH_RADIUS = 6378137.0
MOON_RADIUS = 1737400.0

# -- Detector Array Indices --
DETECTOR_APERTURE_IDX = 0      # Aperture size in meters
DETECTOR_PIXEL_SIZE_IDX = 1    # Pixel size in radians
DETECTOR_QE_IDX = 2            # Quantum efficiency as a fraction (0.0 to 1.0)
DETECTOR_PIXELS_IDX = 3        # Total number of pixels in the detector (count)
DETECTOR_SOLAR_EXCL_IDX = 4    # Solar exclusion angle in radians
DETECTOR_LUNAR_EXCL_IDX = 5    # Lunar exclusion angle in radians
DETECTOR_EARTH_EXCL_IDX = 6    # Earth exclusion angle (above the limb) in radians

# -- Orbital Elements Array Indices --
ORBITAL_A_IDX = 0              # Semi-major axis in meters
ORBITAL_E_IDX = 1              # Eccentricity (dimensionless)
ORBITAL_I_IDX = 2              # Inclination in radians
ORBITAL_RAAN_IDX = 3           # Right Ascension of the Ascending Node in radians
ORBITAL_ARGP_IDX = 4           # Argument of Perigee in radians
ORBITAL_M_IDX = 5              # Mean Anomaly in radians


def initializeStructures(
    num_satellites: int,
    num_observatories: int,
    num_red_satellites: int,
    start_time: datetime
) -> Dict[str, Any]:
    """
    Initializes categorized data structures for a space simulation.

    This function creates distinct sets of data components for different categories
    of entities. It includes kinematic data, orbital elements, sensor pointing
    information, and detailed detector characteristics.

    The 'orbital_elements' component contains the following columns:
    - 0: Semi-major axis (meters)
    - 1: Eccentricity
    - 2: Inclination (radians)
    - 3: Right Ascension of the Ascending Node (radians)
    - 4: Argument of Perigee (radians)
    - 5: Mean Anomaly (radians)

    The 'detector' component contains the following columns:
    - 0: Aperture size (meters)
    - 1: Pixel size (radians)
    - 2: Quantum Efficiency (fraction)
    - 3: Pixel count (total number)
    - 4: Solar exclusion angle (radians)
    - 5: Lunar exclusion angle (radians)
    - 6: Earth exclusion angle (radians, above the limb)

    The 'fixedpoints' component is initialized with a set of 10,000 static points
    in the GCRS frame, generated by `generate_log_spherical_points`. These
    points have a logarithmic radial distribution and are intended for various
    fixed-point calculations or as a reference grid.

    All kinematic data is for the Geocentric Celestial Reference System (GCRS).
    Angles are relative to the International Celestial Reference System (ICRS).
    Distances are in meters, angles in radians, and time in seconds.

    Args:
        num_satellites: The number of regular space-based sensors.
        num_observatories: The number of ground-based sensors.
        num_red_satellites: The number of special "red" satellites.
        start_time: The starting time and date of the simulation. This must be a
                    timezone-aware datetime object set to UTC.

    Returns:
        A dictionary representing the simulation state, containing categorized data.
    """
    # --- Input Validation ---
    if not isinstance(num_satellites, int) or num_satellites < 0:
        raise ValueError("num_satellites must be a non-negative integer.")
    if not isinstance(num_observatories, int) or num_observatories < 0:
        raise ValueError("num_observatories must be a non-negative integer.")
    if not isinstance(num_red_satellites, int) or num_red_satellites < 0:
        raise ValueError("num_red_satellites must be a non-negative integer.")
    if not isinstance(start_time, datetime):
        raise TypeError("start_time must be a datetime object.")
    if start_time.tzinfo is None:
        raise ValueError("start_time must be timezone-aware. Please set tzinfo.")

    num_fixed_points = 100

    # --- Main Data Structure ---
    simulation_data: Dict[str, Any] = {
        'start_time': start_time,
        'counts': {
            'celestial': 2,  # Sun and Moon
            'satellites': num_satellites,
            'observatories': num_observatories,
            'red_satellites': num_red_satellites,
            'fixedpoints': num_fixed_points
        },

        'celestial': {
            'position': np.zeros((2, 3), dtype=float),
            'velocity': np.zeros((2, 3), dtype=float),
            'acceleration': np.zeros((2, 3), dtype=float),
        },

        'satellites': {
            'position': np.zeros((num_satellites, 3), dtype=float),
            'velocity': np.zeros((num_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_satellites, 6), dtype=float),
            'epochs': [], # List to store datetime epochs for each satellite
            'pointing': np.zeros((num_satellites, 3), dtype=float),
            'detector': np.zeros((num_satellites, 7), dtype=float),
        },

        'observatories': {
            'position': np.zeros((num_observatories, 3), dtype=float),
            'velocity': np.zeros((num_observatories, 3), dtype=float),
            'acceleration': np.zeros((num_observatories, 3), dtype=float),
            'pointing': np.zeros((num_observatories, 3), dtype=float),
            'detector': np.zeros((num_observatories, 7), dtype=float),
        },
        
        'red_satellites': {
            'position': np.zeros((num_red_satellites, 3), dtype=float),
            'velocity': np.zeros((num_red_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_red_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_red_satellites, 6), dtype=float),
            'epochs': [],
            'pointing': np.zeros((num_red_satellites, 3), dtype=float),
            'detector': np.zeros((num_red_satellites, 7), dtype=float),
        },

        'fixedpoints': {
            'position': generate_log_spherical_points(
                num_points=num_fixed_points,
                inner_radius=2000000,
                # Outer radius is 2 * geostationary radius (42,164 km)
                # This is an interpretation of "tice geodistances".
                outer_radius=84328000
            )[0], # Only get the positions, not the sizes
            'visibility': np.zeros((num_fixed_points, num_satellites), dtype=int)
        }
    }
    
    return simulation_data

def celestial_update(data_struct: Dict[str, Any], time_date: datetime) -> Dict[str, Any]:
    """
    Calculates and updates the positions of the Sun and Moon.

    This function uses the astropy library to get the precise GCRS coordinates
    of the Sun and Moon for the given time, and updates the 'celestial' position
    component in the main data structure. Velocities and accelerations are not
    calculated and remain zero.

    Args:
        data_struct: The main simulation data dictionary from initializeStructures.
        time_date: The timezone-aware datetime object (in UTC) for the calculation.

    Returns:
        The modified data_struct with updated celestial positions.
    """
    if time_date.tzinfo is None:
        raise ValueError("time_date must be timezone-aware.")

    # Convert the python datetime object to an astropy Time object
    astro_time = Time(time_date)

    # Get Sun position in the GCRS frame using the modern get_body function
    sun_coords = get_body("sun", astro_time)
    sun_gcrs = sun_coords.transform_to(GCRS(obstime=astro_time))
    
    # Get Moon position in the GCRS frame using the modern get_body function
    moon_coords = get_body("moon", astro_time)
    moon_gcrs = moon_coords.transform_to(GCRS(obstime=astro_time))

    # Update the celestial data arrays (index 0 for Sun, 1 for Moon)
    # Position data is converted from astropy's representation to a simple
    # numpy array in meters.
    celestial_pos = data_struct['celestial']['position']
    celestial_pos[0] = sun_gcrs.cartesian.xyz.to(u.m).value
    celestial_pos[1] = moon_gcrs.cartesian.xyz.to(u.m).value
    
    # Per request, velocity and acceleration are not calculated and remain as zeros.

    return data_struct

def readtle(tle_file_path: str) -> Tuple[np.ndarray, List[datetime]]:
    """
    Reads a TLE file and extracts orbital elements and epochs for each satellite.

    Args:
        tle_file_path: The path to the TLE file.

    Returns:
        A tuple containing:
        - A NumPy array of orbital elements.
        - A list of datetime objects representing the epoch for each satellite.
    """
    orbital_elements_list = []
    epochs_list = []
    with open(tle_file_path, 'r') as f:
        lines = f.readlines()

    # Iterate through the file, processing 3 lines at a time (name, line1, line2)
    for i in range(0, len(lines), 3):
        line1 = lines[i+1].strip()
        line2 = lines[i+2].strip()

        # Create a satellite object from the TLE data
        satellite = Satrec.twoline2rv(line1, line2)

        # Use the pre-calculated Julian date from the satellite object
        jd, fr = satellite.jdsatepoch, satellite.jdsatepochF
        epoch_dt = Time(jd, fr, format='jd', scale='utc').to_datetime(timezone.utc)
        epochs_list.append(epoch_dt)

        # Extract and convert orbital elements
        a = satellite.a * satellite.radiusearthkm * 1000.0
        e = satellite.ecco
        inc = satellite.inclo
        raan = satellite.nodeo
        argp = satellite.argpo
        M = satellite.mo

        elements = np.zeros(6)
        elements[ORBITAL_A_IDX] = a
        elements[ORBITAL_E_IDX] = e
        elements[ORBITAL_I_IDX] = inc
        elements[ORBITAL_RAAN_IDX] = raan
        elements[ORBITAL_ARGP_IDX] = argp
        elements[ORBITAL_M_IDX] = M
        orbital_elements_list.append(elements)

    return np.array(orbital_elements_list, dtype=float), epochs_list

def propagate_satellites(data_struct: Dict[str, Any], time_date: datetime) -> Dict[str, Any]:
    """
    Updates satellite positions and pointing vectors based on their orbital elements.

    This function propagates the orbits of all satellites ('satellites' and 
    'red_satellites') from their TLE epoch to the specified time_date
    using Kepler's laws. After calculating the new position, it sets the
    satellite's pointing vector to be radially outward from the Earth's center.

    Args:
        data_struct: The main simulation data dictionary.
        time_date: The timezone-aware datetime object (in UTC) to propagate to.

    Returns:
        The modified data_struct with updated satellite positions and pointing vectors.
    """
    # Earth's standard gravitational parameter (m^3/s^2)
    MU_EARTH = 3.986004418e14
    
    time_date_timestamp = time_date.timestamp()

    for sat_category in ['satellites', 'red_satellites']:
        if data_struct['counts'][sat_category] == 0:
            continue

        elements = data_struct[sat_category]['orbital_elements']
        epochs = data_struct[sat_category]['epochs']
        
        # Calculate the time difference from each satellite's own epoch
        epoch_timestamps = np.array([e.timestamp() for e in epochs])
        delta_t_array = time_date_timestamp - epoch_timestamps

        # Extract orbital elements for all satellites in the category using constants
        a = elements[:, ORBITAL_A_IDX]
        e = elements[:, ORBITAL_E_IDX]
        i = elements[:, ORBITAL_I_IDX]
        raan = elements[:, ORBITAL_RAAN_IDX]
        argp = elements[:, ORBITAL_ARGP_IDX]
        M0 = elements[:, ORBITAL_M_IDX]

        # --- Vectorized Orbit Propagation ---
        
        # 1. Calculate mean motion
        n = np.sqrt(MU_EARTH / a**3)
        
        # 2. Calculate new mean anomaly
        M = (M0 + n * delta_t_array) % (2 * np.pi)

        # 3. Solve Kepler's Equation for Eccentric Anomaly (E) using Newton's method
        E = M.copy()  # Initial guess
        for _ in range(10): # Iterate a few times for convergence
            f_E = E - e * np.sin(E) - M
            f_prime_E = 1 - e * np.cos(E)
            # Avoid division by zero for circular orbits
            f_prime_E[f_prime_E == 0] = 1e-10
            E = E - f_E / f_prime_E

        # 4. Calculate True Anomaly (Î½)
        tan_nu_half = np.sqrt((1 + e) / (1 - e)) * np.tan(E / 2)
        nu = 2 * np.arctan(tan_nu_half)

        # 5. Calculate distance from center of Earth (r)
        r = a * (1 - e * np.cos(E))

        # 6. Calculate position in the perifocal (orbital) frame
        x_pqw = r * np.cos(nu)
        y_pqw = r * np.sin(nu)

        # 7. Rotate from perifocal to GCRS frame
        cos_raan = np.cos(raan)
        sin_raan = np.sin(raan)
        cos_argp = np.cos(argp)
        sin_argp = np.sin(argp)
        cos_i = np.cos(i)
        sin_i = np.sin(i)

        # Rotation matrix elements from PQW to GCRS (IJK)
        P_x = cos_argp * cos_raan - sin_argp * sin_raan * cos_i
        P_y = cos_argp * sin_raan + sin_argp * cos_raan * cos_i
        P_z = sin_argp * sin_i
        
        Q_x = -sin_argp * cos_raan - cos_argp * sin_raan * cos_i
        Q_y = -sin_argp * sin_raan + cos_argp * cos_raan * cos_i
        Q_z = cos_argp * sin_i

        # Perform the rotation
        x_gcrs = x_pqw * P_x + y_pqw * Q_x
        y_gcrs = x_pqw * P_y + y_pqw * Q_y
        z_gcrs = x_pqw * P_z + y_pqw * Q_z
        
        # Update the position array in the data structure
        positions = np.vstack((x_gcrs, y_gcrs, z_gcrs)).T
        data_struct[sat_category]['position'] = positions

        # --- Set pointing vector to be radially outward ---
        # Normalize the position vectors to get unit pointing vectors.
        norms = np.linalg.norm(positions, axis=1)[:, np.newaxis]
        # Avoid division by zero for any satellites at the origin.
        norms[norms == 0] = 1.0
        data_struct[sat_category]['pointing'] = positions / norms

    return data_struct

def solarexclusion(data_struct: Dict[str, Any]) -> Tuple[np.ndarray, np.ndarray]:
    """
    Calculates solar exclusion for all satellites based on their pointing vectors.

    This function operates in a vectorized manner on all satellites in the
    'satellites' category. It computes the angle between each satellite's
    pointing vector and the vector from the satellite to the Sun.

    Args:
        data_struct: The main simulation data dictionary.

    Returns:
        A tuple containing:
        - exclusion_vector (np.ndarray): An array of the same length as the
          number of satellites. An element is 1 if the satellite is within
          the solar exclusion angle, 0 otherwise.
        - angle_vector (np.ndarray): An array containing the calculated angle
          in radians for each satellite.
    """
    num_sats = data_struct['counts']['satellites']
    if num_sats == 0:
        return np.array([]), np.array([])

    # Get required data from the main structure
    sun_pos = data_struct['celestial']['position'][0]
    sat_pos = data_struct['satellites']['position']
    sat_pointing = data_struct['satellites']['pointing']
    solar_exclusion_angles = data_struct['satellites']['detector'][:, DETECTOR_SOLAR_EXCL_IDX]

    # Calculate the vector from each satellite to the Sun
    vec_sat_to_sun = sun_pos - sat_pos

    # Normalize the vectors
    norm_sat_to_sun = np.linalg.norm(vec_sat_to_sun, axis=1)
    norm_sat_pointing = np.linalg.norm(sat_pointing, axis=1)

    # Avoid division by zero for zero-length vectors.
    # A zero-length pointing vector can't have an angle, so we create a
    # mask to handle these cases safely.
    valid_norms = (norm_sat_to_sun > 1e-9) & (norm_sat_pointing > 1e-9)

    # Initialize angle vector with a default value (pi = 180 deg) for invalid cases
    angle_vector = np.full(num_sats, np.pi)

    # Calculate dot product only for vectors with valid norms
    if np.any(valid_norms):
        dot_product = np.einsum('ij,ij->i', vec_sat_to_sun[valid_norms], sat_pointing[valid_norms])

        # Calculate the angle where possible
        cos_angle = dot_product / (norm_sat_to_sun[valid_norms] * norm_sat_pointing[valid_norms])

        # Clip to handle potential floating point inaccuracies
        cos_angle = np.clip(cos_angle, -1.0, 1.0)

        angle_vector[valid_norms] = np.arccos(cos_angle)

    # Determine exclusion based on the angle
    exclusion_vector = (angle_vector < solar_exclusion_angles).astype(int)

    return exclusion_vector, angle_vector

def exclusion(
    data_struct: Dict[str, Any],
    satellite_index: int,
    print_debug: bool = False
) -> int:
    """
    Determines if a satellite's pointing vector is excluded by the Sun, Moon, or Earth.

    Args:
        data_struct: The main simulation data dictionary.
        satellite_index: The index of the satellite to check.
        print_debug: If True, prints detailed debug information for the calculation.

    Returns:
        0 if the satellite's view is excluded, 1 otherwise.
    """
    # --- 1. Extract Data ---
    sat_pos = data_struct['satellites']['position'][satellite_index]
    sat_pointing = data_struct['satellites']['pointing'][satellite_index]
    sun_pos = data_struct['celestial']['position'][0]
    moon_pos = data_struct['celestial']['position'][1]
    
    detector_props = data_struct['satellites']['detector'][satellite_index]
    solar_excl_angle = detector_props[DETECTOR_SOLAR_EXCL_IDX]
    lunar_excl_angle = detector_props[DETECTOR_LUNAR_EXCL_IDX]
    earth_excl_angle = detector_props[DETECTOR_EARTH_EXCL_IDX]

    # --- 2. Compute Vectors and Normalize ---
    vec_to_sun = sun_pos - sat_pos
    vec_to_moon = moon_pos - sat_pos
    vec_to_earth = -sat_pos

    dist_to_sun = np.linalg.norm(vec_to_sun)
    dist_to_moon = np.linalg.norm(vec_to_moon)
    dist_to_earth = np.linalg.norm(vec_to_earth)
    
    u_vec_to_sun = vec_to_sun / dist_to_sun if dist_to_sun > 0 else np.array([0.,0.,0.])
    u_vec_to_moon = vec_to_moon / dist_to_moon if dist_to_moon > 0 else np.array([0.,0.,0.])
    u_vec_to_earth = vec_to_earth / dist_to_earth if dist_to_earth > 0 else np.array([0.,0.,0.])
    
    norm_pointing = np.linalg.norm(sat_pointing)
    u_sat_pointing = sat_pointing / norm_pointing if norm_pointing > 0 else np.array([0.,0.,0.])

    # --- 3. Calculate Angles and Check for Exclusion ---
    sun_flag, moon_flag, earth_flag = False, False, False

    cos_angle_sun = np.clip(np.dot(u_sat_pointing, u_vec_to_sun), -1.0, 1.0)
    angle_sun = np.arccos(cos_angle_sun)
    if angle_sun < solar_excl_angle:
        sun_flag = True

    cos_angle_moon = np.clip(np.dot(u_sat_pointing, u_vec_to_moon), -1.0, 1.0)
    angle_moon = np.arccos(cos_angle_moon)
    apparent_radius_moon = np.arctan(MOON_RADIUS / dist_to_moon) if dist_to_moon > 0 else 0
    if (angle_moon - apparent_radius_moon) < lunar_excl_angle:
        moon_flag = True

    cos_angle_earth = np.clip(np.dot(u_sat_pointing, u_vec_to_earth), -1.0, 1.0)
    angle_earth = np.arccos(cos_angle_earth)
    apparent_radius_earth = np.arctan(EARTH_RADIUS / dist_to_earth) if dist_to_earth > 0 else 0
    if (angle_earth - apparent_radius_earth) < earth_excl_angle:
        earth_flag = True

    # --- 4. Optional Debug Printing ---
    if print_debug:
        print(f"\n--- Exclusion Debug for Satellite {satellite_index} ---")
        print(f"  - Sat Position: {np.array2string(sat_pos, precision=3)}")
        print(f"  - Sat Pointing: {np.array2string(u_sat_pointing, precision=3)}")
        print("-" * 20)
        print(f"  - Sun Flag:   {sun_flag}")
        print(f"    - Angle to Sun: {np.rad2deg(angle_sun):.2f} deg")
        print(f"    - Exclusion Angle: {np.rad2deg(solar_excl_angle):.2f} deg")
        print("-" * 20)
        print(f"  - Moon Flag:  {moon_flag}")
        print(f"    - Angle to Moon: {np.rad2deg(angle_moon):.2f} deg")
        print(f"    - Apparent Radius: {np.rad2deg(apparent_radius_moon):.2f} deg")
        print(f"    - Exclusion Angle: {np.rad2deg(lunar_excl_angle):.2f} deg")
        print("-" * 20)
        print(f"  - Earth Flag: {earth_flag}")
        print(f"    - Angle to Earth: {np.rad2deg(angle_earth):.2f} deg")
        print(f"    - Apparent Radius: {np.rad2deg(apparent_radius_earth):.2f} deg")
        print(f"    - Exclusion Angle: {np.rad2deg(earth_excl_angle):.2f} deg")
        print("-" * 20)

    # --- 5. Set Global Exclusion Flag and Return ---
    is_excluded = sun_flag or moon_flag or earth_flag
    return 0 if is_excluded else 1


def update_visibility_table(
    data_struct: Dict[str, Any],
    print_debug_for_sat: Optional[int] = None
) -> None:
    """
    Updates the visibility table for each satellite against each fixed point.

    Args:
        data_struct: The main simulation data dictionary.
        print_debug_for_sat: If an integer is provided, the `exclusion` function's
                             debug printout will be enabled for that satellite index.
    """
    num_satellites = data_struct['counts']['satellites']
    fixed_points = data_struct['fixedpoints']['position']
    num_fixed_points = len(fixed_points)
    visibility_table = data_struct['fixedpoints']['visibility']

    if num_satellites == 0 or num_fixed_points == 0:
        return

    satellite_positions = data_struct['satellites']['position']

    for i in range(num_satellites):
        sat_pos = satellite_positions[i]
        
        # Determine if we should print debug info for this satellite
        should_print_debug = (i == print_debug_for_sat)

        for j in range(num_fixed_points):
            fixed_point_pos = fixed_points[j]
            pointing_vector = fixed_point_pos - sat_pos
            data_struct['satellites']['pointing'][i] = pointing_vector
            
            visibility_table[j, i] = exclusion(data_struct, i, print_debug=should_print_debug)
