* AGENT INSTRUCTIONS FOR VIBEVOLTS CODEBASE

This document provides context and guidance for an AI
agent tasked with improving the `vibevolts` Python-based
space simulation project.

** 1. Project Overview

The primary goal of the `vibevolts` project is to create
a fast and efficient simulation tool for modeling
satellite and observatory visibility of objects in space.
The user is refactoring an older tool ("volts") with a
focus on performance, leveraging vectorized operations
with NumPy and established astronomical libraries. The
simulation involves propagating satellite orbits,
calculating celestial body positions, determining viewing
exclusions (e.g., from the Sun, Moon, Earth), and
ultimately scoring the visibility of a predefined set of
points in space.

** 2. File Descriptions

The repository contains the following key files:

- `vibevolts.py`: This is the main script and simulation
  engine. It initializes all data structures, reads
  satellite TLE data, propagates orbits, calculates
  celestial positions, and contains the logic for
  determining viewing exclusions. It also includes several
  `demo` functions for visualization.

- `generate_log_spherical_points.py`: A utility script
  that creates a 3D point cloud of "fixed points" to be
  observed. These points are distributed with logarithmic
  spacing radially and uniform spacing angularly. This file
  is used to generate the observation targets in the main
  simulation.

- `lambertiansphere.py`: A physics utility function to
  calculate the effective brightness (cross-section) of a
  diffusely reflecting sphere (a "Lambertian sphere").
  This is likely intended for future use in signal-to-noise
  ratio (SNR) calculations.

- `radiometry.py`: A data and utility module containing
  standard astronomical filter data, functions for
  magnitude conversions, and blackbody radiation
  calculations. This supports the physics-based modeling
  of light detection.

- `vibevolts.org`: An org-mode file that serves as the
  developer's log. It contains a to-do list, design notes,
  and prompts that were used to generate parts of the code.
  This file is a crucial source for understanding the
  user's intent and future development goals.

** 3. Key Data Structures

The simulation state is managed within a single, large
dictionary created by the `initializeStructures` function
in `vibevolts.py`.

- *simulation_data* (dict): The root object.

  - 'counts': Stores the number of satellites,
    observatories, etc.

  - 'celestial': A NumPy array `(2, 3)` for the positions
    of the Sun and Moon.

  - 'satellites', 'observatories', 'red_satellites':
    Dictionaries containing NumPy arrays for position,
    velocity, pointing, and detector properties. The
    `orbital_elements` and `epochs` are used for
    propagation.

  - 'fixedpoints': A dictionary containing a NumPy array
    `(N, 3)` of static target points in the GCRS frame,
    generated by `generate_log_spherical_points.py`.

The code uses integer constants (e.g.,
`DETECTOR_SOLAR_EXCL_IDX`) as indices for accessing
columns in the NumPy arrays, which is an efficient but
potentially error-prone pattern.

** 4. Core Functionality & Algorithms

- *Orbit Propagation*: `propagate_satellites` uses a
  vectorized implementation of Kepler's laws to calculate
  satellite positions at a given time from their
  TLE-derived orbital elements. It does not use a
  numerical integrator, opting for an analytical approach.

- *Celestial Mechanics*: `celestial_update` uses the
  `astropy` library to get high-precision positions for the
  Sun and Moon.

- *Exclusion Calculation*: The `exclusion` function
  calculates whether a single satellite's line of sight is
  blocked by the Sun, Moon, or Earth. The
  `create_exclusion_table` function iterates this check for
  every satellite against every fixed point. *This is a
  performance bottleneck due to its nested loops.*

- *Vectorization*: The code effectively uses NumPy for many
  calculations, such as in `propagate_satellites` and
  `solarexclusion`. The user's goal is to maximize the use
  of vectorized operations.

** 5. User's Stated Development Goals (from `vibevolts.org`)

The user's immediate to-do list includes:

1. *Visibility Matrix*: Create a 2D array where rows
   represent simulation time steps and columns represent
   targets. The value would be a flag indicating if a
   target is visible.

2. *SNR Calculation*: As part of the visibility check,
   compute if the signal-to-noise ratio (SNR) is high
   enough for a detection. This will likely involve using
   `lambertiansphere.py` and `radiometry.py`.

3. *Pointing Selection*: Develop a more sophisticated
   algorithm for selecting where satellites should point.

4. *Scoring*: Implement scoring logic based on the
   visibility matrix, calculating metrics like the
   fraction of time a target is observed and the
   distribution of observation gap times.

** 6. Suggestions for Improvement

When modifying the code, prioritize the following areas:

1. *Performance*: The user's primary goal is speed. The
   most significant opportunity for improvement is
   vectorizing functions that apply across the entities
   using numpy, using a so called entity component method
   architecture. If possible avoid nested loops and
   used NumPy code such as Numpy Broadcasting.
   

2. *Modularity*: `vibevolts.py` is becoming a very large
   file. Propose breaking it down into more logical
   modules. For example:

   - `simulation.py`: For the main data structures and
     state management.

   - `propagation.py`: For `propagate_satellites` and
     `celestial_update`.

   - `visibility.py`: For `exclusion`, `solarexclusion`,
     and the new vectorized `create_exclusion_table`.

   - `visualization.py`: For the Plotly-based `demo`
     functions.

3. *Configuration*: The demo functions currently have TLE
   data hardcoded as multi-line strings. Recommend moving
   this and other simulation parameters (like start time,
   number of points, etc.) into a separate configuration
   file (e.g., `config.json` or `config.yaml`) to make the
   simulation more flexible.

4. *Object Orientation*: Use object orientation sparingly.
   Do not add any object oriented features to the code
   without being instructed or having the plan approved.
   In general the code should be a series of functions
   that operate on the central data structure.

