#+TITLE: VibeVolts Documentation

This document provides an overview of the data structures,
functions, and dependencies for the VibeVolts simulation
toolkit.

* 1. Common Data Structures

The toolkit uses two primary data structures to manage
simulation state and physical constants.

** 1.1. Simulation State Dictionary (~simulation_data~)

This is the central data structure, created by the
~initializeStructures~ function in ~vibevolts.py~. It is a
Python dictionary that organizes all simulation entities into
categories.

#+BEGIN_SRC python
{
    'start_time': datetime,
    'counts': {
        'celestial': 2,
        'satellites': num_satellites,
        'observatories': num_observatories,
        'red_satellites': num_red_satellites
    },
    'celestial': {
        'position': np.zeros((2, 3)),
        'velocity': np.zeros((2, 3)),
        'acceleration': np.zeros((2, 3)),
    },
    'satellites': {
        'position': np.zeros((num_satellites, 3)),
        'velocity': np.zeros((num_satellites, 3)),
        'acceleration': np.zeros((num_satellites, 3)),
        'orbital_elements': np.zeros((num_satellites, 6)),
        'epochs': [],
        'pointing': np.zeros((num_satellites, 3)),
        'detector': np.zeros((num_satellites, 7)),
    },
    'observatories': { ... },
    'red_satellites': { ... }
}
#+END_SRC

*** Key Components:

- */orbital_elements/*: A NumPy array (~n x 6~) containing the
  classical orbital elements for each satellite. The columns
  are:
  - ~0~: Semi-major axis (meters)
  - ~1~: Eccentricity
  - ~2~: Inclination (radians)
  - ~3~: Right Ascension of the Ascending Node (radians)
  - ~4~: Argument of Perigee (radians)
  - ~5~: Mean Anomaly (radians)

- */detector/*: A NumPy array (~n x 7~) containing the
  properties of each sensor. The columns are:
  - ~0~: Aperture size (meters)
  - ~1~: Pixel size (radians)
  - ~2~: Quantum Efficiency (fraction)
  - ~3~: Pixel count
  - ~4~: Solar exclusion angle (radians)
  - ~5~: Lunar exclusion angle (radians)
  - ~6~: Earth exclusion angle (radians)

** 1.2. Radiometric Filter Data (~FILTER_DATA~)

This dictionary, located in ~radiometry.py~, provides standard data for a variety of astronomical filters, including Johnson-Cousins, SDSS, and JWST.

- *sun*: The apparent magnitude of the Sun in the given filter.
- *sky*: The typical dark sky brightness in magnitudes per square arcsecond.
- *central_wavelength*: The central wavelength of the filter passband in nanometers (nm).
- *bandwidth*: The effective width of the filter passband in nanometers (nm).
- *zero_point*: The photon flux (in photons/sec/mÂ²) corresponding to a 0-magnitude star.

#+BEGIN_SRC python
{
    'U': {
        'sun': -26.03,
        'sky': 22.0,
        'central_wavelength': 365.0,
        'bandwidth': 66.0,
        'zero_point': 4.96e9,
    },
    'B': { ... },
    # ... and so on for V, R, I, J, H, K, g, r, i, z, L, M, N, and JWST filters.
}
#+END_SRC

** 1.3. Physical Constants

The ~radiometry.py~ module also defines the following physical constants:

- *AU_M*: The astronomical unit in meters (~1.496e+11 m~).
- *RSUN_M*: The radius of the Sun in meters (~6.957e+08 m~).

* 2. Existing Functions

This section describes the functions available in the toolkit, organized by module.

** 2.1. ~vibevolts.py~

- *initializeStructures(num_satellites, num_observatories, num_red_satellites, start_time)*: Creates and returns the main ~simulation_data~ dictionary.
- *celestial_update(data_struct, time_date)*: Updates the positions of the Sun and Moon for a given time using the ~astropy~ library.
- *readtle(tle_file_path)*: Reads a Two-Line Element (TLE) file and returns a NumPy array of orbital elements and a list of epoch datetimes.
- *propagate_satellites(data_struct, time_date)*: Updates satellite positions based on their orbital elements to a new time using a vectorized Keplerian propagator.
- *plot_positions_3d(positions, title, plot_time, labels)*: Displays an interactive 3D plot of object positions using ~plotly~.
- *solarexclusion(data_struct)*: Calculates solar exclusion for all satellites based on their pointing vectors. Returns a tuple containing an ~exclusion_vector~ (1 for excluded, 0 for clear) and an ~angle_vector~ (the calculated angle in radians for each satellite).
- *exclusion(data_struct, satellite_index)*: The primary function that checks for viewing exclusion. It takes the main simulation data structure and a satellite index and returns ~True~ if the satellite's pointing vector is within the exclusion zone of the Sun, Moon, or Earth, and ~False~ otherwise.
- *create_exclusion_table(data_struct)*: Creates a 2D NumPy array where rows correspond to satellites and columns correspond to fixed points. A cell value of 1 means the view is excluded, and 0 means it is clear.
- *demo1()*, *demo2()*, *demo3()*, *demo4()*, *demo5()*: Demonstration functions that run pre-configured simulations and generate plots.
- *demo_fixedpoints()*: Demonstrates the ~fixedpoints~ data structure by plotting it in 3D.
- *demo_exclusion_table()*: Demonstrates the creation and visualization of the exclusion table.

** 2.2. ~radiometry.py~

- *mag(x)*: Converts a linear flux ratio to an astronomical magnitude.
- *amag(x)*: Converts an astronomical magnitude back to a linear flux ratio.
- *blackbody_flux(temperature, lambda_short, lambda_long)*: Computes the integrated spectral radiance of a blackbody over a wavelength band.
- *stefan_boltzmann_law(temperature)*: Calculates the total power radiated per unit area by a blackbody.
- *plot_blackbody_spectrum(temperature)*: Plots the spectral radiance of a blackbody from 0.5 to 30 microns.
- *plot_blackbody_spectrum_visible_nir(temperature)*: Plots the spectral radiance of a blackbody from 0.1 to 1 micron.

** 2.3. ~lambertiansphere.py~

- *lambertiansphere(vec_from_sphere_to_light, vec_from_sphere_to_observer, albedo, radius)*: Calculates the effective brightness cross-section (in square meters) of a diffusely reflecting (Lambertian) sphere based on illumination geometry, albedo, and size.

** 2.4. ~generate_log_spherical_points.py~

- *generate_log_spherical_points(num_points, inner_radius, outer_radius, seed)*: Generates a set of 3D points with logarithmic radial and uniform angular distribution.
- *visualize_point_distribution(points)*: Visualizes the distribution of a 3D point cloud with four plots.

* 3. Dependencies

To run the VibeVolts code, the following Python modules must be installed. You can install them using pip.

Note: The ~vibevolts.py~ module also has an internal dependency on ~generate_log_spherical_points.py~, which is included in this repository.

- ~numpy~: For numerical operations and array manipulation.
- ~astropy~: For astronomical calculations and coordinate transformations.
- ~jplephem~: Used by ~astropy~ for planetary ephemeris calculations.
- ~sgp4~: For parsing TLE satellite data.
- ~plotly~: For creating interactive 3D plots.
- ~scipy~: For scientific computations, specifically numerical integration in ~radiometry.py~.

Example installation command:
#+BEGIN_SRC bash
pip install numpy astropy jplephem sgp4 plotly scipy
#+END_SRC
