import numpy as np
from datetime import datetime, timezone
from typing import Dict, Any
from generate_log_spherical_points import generate_log_spherical_points
from constants import *


def initializeStructures(
    num_satellites: int,
    num_observatories: int,
    num_red_satellites: int,
    start_time: datetime,
    delta_time: float = 60.0
) -> Dict[str, Any]:
    """
    Initializes categorized data structures for a space simulation.

    This function creates distinct sets of data components for different categories
    of entities. It includes kinematic data, orbital elements, sensor pointing
    information, and detailed detector characteristics.

    The 'orbital_elements' component contains the following columns:
    - 0: Semi-major axis (meters)
    - 1: Eccentricity
    - 2: Inclination (radians)
    - 3: Right Ascension of the Ascending Node (radians)
    - 4: Argument of Perigee (radians)
    - 5: Mean Anomaly (radians)

    The 'detector' component contains the following columns:
    - 0: Aperture size (meters)
    - 1: Pixel size (radians)
    - 2: Quantum Efficiency (fraction)
    - 3: Pixel count (total number)
    - 4: Solar exclusion angle (radians)
    - 5: Lunar exclusion angle (radians)
    - 6: Earth exclusion angle (radians, above the limb)

    The 'fixedpoints' component is initialized with a set of 10,000 static points
    in the GCRS frame, generated by `generate_log_spherical_points`. These
    points have a logarithmic radial distribution and are intended for various
    fixed-point calculations or as a reference grid.

    All kinematic data is for the Geocentric Celestial Reference System (GCRS).
    Angles are relative to the International Celestial Reference System (ICRS).
    Distances are in meters, angles in radians, and time in seconds.

    Args:
        num_satellites: The number of regular space-based sensors.
        num_observatories: The number of ground-based sensors.
        num_red_satellites: The number of special "red" satellites.
        start_time: The starting time and date of the simulation. This must be a
                    timezone-aware datetime object set to UTC.

    Returns:
        A dictionary representing the simulation state, containing categorized data.
    """
    # --- Input Validation ---
    if not isinstance(num_satellites, int) or num_satellites < 0:
        raise ValueError("num_satellites must be a non-negative integer.")
    if not isinstance(num_observatories, int) or num_observatories < 0:
        raise ValueError("num_observatories must be a non-negative integer.")
    if not isinstance(num_red_satellites, int) or num_red_satellites < 0:
        raise ValueError("num_red_satellites must be a non-negative integer.")
    if not isinstance(start_time, datetime):
        raise TypeError("start_time must be a datetime object.")
    if start_time.tzinfo is None:
        raise ValueError("start_time must be timezone-aware. Please set tzinfo.")

    num_fixed_points = 100

    # --- Main Data Structure ---
    simulation_data: Dict[str, Any] = {
        'start_time': start_time,
        'delta_time': delta_time,
        'counts': {
            'celestial': 2,  # Sun and Moon
            'satellites': num_satellites,
            'observatories': num_observatories,
            'red_satellites': num_red_satellites,
            'fixedpoints': num_fixed_points
        },

        'celestial': {
            'position': np.zeros((2, 3), dtype=float),
            'velocity': np.zeros((2, 3), dtype=float),
            'acceleration': np.zeros((2, 3), dtype=float),
        },

        'satellites': {
            'position': np.zeros((num_satellites, 3), dtype=float),
            'velocity': np.zeros((num_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_satellites, 6), dtype=float),
            'epochs': [], # List to store datetime epochs for each satellite
            'pointing': np.zeros((num_satellites, 3), dtype=float),
            'pointing_state': np.zeros((num_satellites, 2), dtype=int),
            'detector': np.zeros((num_satellites, 7), dtype=float),
        },

        # Explicitly defining pointing_spheres to resolve potential sync issues.
        'pointing_spheres': {},

        'observatories': {
            'position': np.zeros((num_observatories, 3), dtype=float),
            'velocity': np.zeros((num_observatories, 3), dtype=float),
            'acceleration': np.zeros((num_observatories, 3), dtype=float),
            'pointing': np.zeros((num_observatories, 3), dtype=float),
            'detector': np.zeros((num_observatories, 7), dtype=float),
        },

        'red_satellites': {
            'position': np.zeros((num_red_satellites, 3), dtype=float),
            'velocity': np.zeros((num_red_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_red_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_red_satellites, 6), dtype=float),
            'epochs': [],
            'pointing': np.zeros((num_red_satellites, 3), dtype=float),
            'detector': np.zeros((num_red_satellites, 7), dtype=float),
        },

        'fixedpoints': {
            'position': generate_log_spherical_points(
                num_points=num_fixed_points,
                inner_radius=2000000,
                # Outer radius is 2 * geostationary radius (42,164 km)
                # This is an interpretation of "tice geodistances".
                outer_radius=84328000
            )[0], # Only get the positions, not the sizes
            'visibility': np.zeros((num_fixed_points, num_satellites), dtype=int)
        }
    }

    return simulation_data
