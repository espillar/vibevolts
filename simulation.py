import numpy as np
from datetime import datetime, timezone
from typing import Dict, Any
from generate_log_spherical_points import generate_log_spherical_points

# --- Global Constants for Array Indices ---
# These constants define column indices for numpy arrays, making the
# code more readable and preventing errors from using "magic numbers".

# -- Radii in Meters --
EARTH_RADIUS = 6378137.0
MOON_RADIUS = 1737400.0

# -- Detector Array Indices --
DETECTOR_APERTURE_IDX = 0      # Aperture size in meters
DETECTOR_PIXEL_SIZE_IDX = 1    # Pixel size in radians
DETECTOR_QE_IDX = 2            # Quantum efficiency as a fraction (0.0 to 1.0)
DETECTOR_PIXELS_IDX = 3        # Total number of pixels in the detector (count)
DETECTOR_SOLAR_EXCL_IDX = 4    # Solar exclusion angle in radians
DETECTOR_LUNAR_EXCL_IDX = 5    # Lunar exclusion angle in radians
DETECTOR_EARTH_EXCL_IDX = 6    # Earth exclusion angle (above the limb) in radians

# -- Orbital Elements Array Indices --
ORBITAL_A_IDX = 0              # Semi-major axis in meters
ORBITAL_E_IDX = 1              # Eccentricity (dimensionless)
ORBITAL_I_IDX = 2              # Inclination in radians
ORBITAL_RAAN_IDX = 3           # Right Ascension of the Ascending Node in radians
ORBITAL_ARGP_IDX = 4           # Argument of Perigee in radians
ORBITAL_M_IDX = 5              # Mean Anomaly in radians

# -- Pointing State Array Indices --
POINTING_COUNT_IDX = 0         # Number of points in the pointing grid
POINTING_PLACE_IDX = 1         # Current index in the pointing sequence


def initializeStructures(
    num_satellites: int,
    num_observatories: int,
    num_red_satellites: int,
    start_time: datetime,
    delta_time: float = 60.0
) -> Dict[str, Any]:
    """
    Initializes categorized data structures for a space simulation.

    This function creates distinct sets of data components for different categories
    of entities. It includes kinematic data, orbital elements, sensor pointing
    information, and detailed detector characteristics.

    The 'orbital_elements' component contains the following columns:
    - 0: Semi-major axis (meters)
    - 1: Eccentricity
    - 2: Inclination (radians)
    - 3: Right Ascension of the Ascending Node (radians)
    - 4: Argument of Perigee (radians)
    - 5: Mean Anomaly (radians)

    The 'detector' component contains the following columns:
    - 0: Aperture size (meters)
    - 1: Pixel size (radians)
    - 2: Quantum Efficiency (fraction)
    - 3: Pixel count (total number)
    - 4: Solar exclusion angle (radians)
    - 5: Lunar exclusion angle (radians)
    - 6: Earth exclusion angle (radians, above the limb)

    The 'fixedpoints' component is initialized with a set of 10,000 static points
    in the GCRS frame, generated by `generate_log_spherical_points`. These
    points have a logarithmic radial distribution and are intended for various
    fixed-point calculations or as a reference grid.

    All kinematic data is for the Geocentric Celestial Reference System (GCRS).
    Angles are relative to the International Celestial Reference System (ICRS).
    Distances are in meters, angles in radians, and time in seconds.

    Args:
        num_satellites: The number of regular space-based sensors.
        num_observatories: The number of ground-based sensors.
        num_red_satellites: The number of special "red" satellites.
        start_time: The starting time and date of the simulation. This must be a
                    timezone-aware datetime object set to UTC.

    Returns:
        A dictionary representing the simulation state, containing categorized data.
    """
    # --- Input Validation ---
    if not isinstance(num_satellites, int) or num_satellites < 0:
        raise ValueError("num_satellites must be a non-negative integer.")
    if not isinstance(num_observatories, int) or num_observatories < 0:
        raise ValueError("num_observatories must be a non-negative integer.")
    if not isinstance(num_red_satellites, int) or num_red_satellites < 0:
        raise ValueError("num_red_satellites must be a non-negative integer.")
    if not isinstance(start_time, datetime):
        raise TypeError("start_time must be a datetime object.")
    if start_time.tzinfo is None:
        raise ValueError("start_time must be timezone-aware. Please set tzinfo.")

    num_fixed_points = 100

    # --- Main Data Structure ---
    simulation_data: Dict[str, Any] = {
        'start_time': start_time,
        'delta_time': delta_time,
        'counts': {
            'celestial': 2,  # Sun and Moon
            'satellites': num_satellites,
            'observatories': num_observatories,
            'red_satellites': num_red_satellites,
            'fixedpoints': num_fixed_points
        },

        'celestial': {
            'position': np.zeros((2, 3), dtype=float),
            'velocity': np.zeros((2, 3), dtype=float),
            'acceleration': np.zeros((2, 3), dtype=float),
        },

        'satellites': {
            'position': np.zeros((num_satellites, 3), dtype=float),
            'velocity': np.zeros((num_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_satellites, 6), dtype=float),
            'epochs': [], # List to store datetime epochs for each satellite
            'pointing': np.zeros((num_satellites, 3), dtype=float),
            'pointing_state': np.zeros((num_satellites, 2), dtype=int),
            'detector': np.zeros((num_satellites, 7), dtype=float),
        },

        'pointing_spheres': {},

        'observatories': {
            'position': np.zeros((num_observatories, 3), dtype=float),
            'velocity': np.zeros((num_observatories, 3), dtype=float),
            'acceleration': np.zeros((num_observatories, 3), dtype=float),
            'pointing': np.zeros((num_observatories, 3), dtype=float),
            'detector': np.zeros((num_observatories, 7), dtype=float),
        },

        'red_satellites': {
            'position': np.zeros((num_red_satellites, 3), dtype=float),
            'velocity': np.zeros((num_red_satellites, 3), dtype=float),
            'acceleration': np.zeros((num_red_satellites, 3), dtype=float),
            'orbital_elements': np.zeros((num_red_satellites, 6), dtype=float),
            'epochs': [],
            'pointing': np.zeros((num_red_satellites, 3), dtype=float),
            'detector': np.zeros((num_red_satellites, 7), dtype=float),
        },

        'fixedpoints': {
            'position': generate_log_spherical_points(
                num_points=num_fixed_points,
                inner_radius=2000000,
                # Outer radius is 2 * geostationary radius (42,164 km)
                # This is an interpretation of "tice geodistances".
                outer_radius=84328000
            )[0], # Only get the positions, not the sizes
            'visibility': np.zeros((num_fixed_points, num_satellites), dtype=int)
        }
    }

    return simulation_data
